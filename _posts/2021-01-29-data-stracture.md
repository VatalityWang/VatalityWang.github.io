---
layout: post
title: data structure
categories: 学习
description: note
keywords: 散列表
---

<head>
    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
            tex2jax: {
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
            inlineMath: [['$','$']]
            }
        });
    </script>
</head>





# 1 散列表

## 1.1 定义

实现字典操作的一种有效数据结构。用一个长度与实际存储的关键字数目成比例的数组来存储元素。不把关键字作为下标，而是根据关键字计算出下标。

## 1.2 冲突解决

### 1.2.1  链接法解决冲突

![散列表](/images/blog/散列表.png)

* 双向链表加快插入和删除，最坏情况下都是O(1);
* 给定一个能存放n个元素的，具有m个槽位的散列表T,装载因子$\alpha$=n/m。
* 简单均匀散列假设下，链接法解决冲突，不成功和成功查找平均时间都为$\theta(1+\alpha)$.
* 如果散列表中槽数和元素个数成正比，则$n=\theta(m)$,$\alpha=n/m=O(m)/m=O(1)$,从而查找操作平均需要常数时间。

### 1.2.2  散列函数h(k)

#### 1.2.2.1 什么是好的散列函数

近似满足均匀假设，每个关键字被等可能散列到m个槽位中。

#### 1.2.2.2 常用散列函数

* 除法散列

  h(k)=k*mod*m

  m一般取不太接近2的整数幂的素数。

* 乘法散列
# 2 B 树

![img](E:\SelfStudy\DamonWang888.github.io\_posts\images\1460000020416594)

## 2.1 定义
一棵B树是具有一下性质的有根树(自平衡多叉树)：
每个节点x具有下面属性：

* x.n 节点关键字个数；
* x.n个关键字以非降序排列；
* x.leaf bool类型指示是否是叶子节点；
* 每个内部x具有x.n+1个指向其他孩子的指针，x中的关键字对各子树中的关键字范围加以分隔；
* 每个叶节点具有相同的深度，即树的高度h;
* 每个节点包含的关键字个数有上界和下界。用t(t>=2)来表示B树的最小度数(minmum num);
* 除根节点外每个节点必须至少有t-1个关键字；除根节点外每个内部节点至少有t个孩子，如果树非空，则根节点至少有一个关键字；
* 每个节点至多包含2t-1个关键字。因此，一个内部节点至多有2t个孩子。当一个节点恰好有2t-个关键字时，称该节点是满的。
											                                                                                                                                                                            ------《算法导论》 p279-280

## 2.1 高度

一棵最小度数为t>=2的,含有n(>=1)个关键字的，高度为h的B树满足：

$h<=log_t \frac{n+1}{2}$

# 3 B+ 树

自平衡多叉树。基本定义与B树相同，不同点是数据只出现在叶子节点上，所有叶子节点间增加了一个链指针方便进行范围查询。

可视化网址：https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html

![img](\images\v2-5f069fd820637db1b877fdd6799a2b67_720w.jpg)

![img](\images\v2-9644d1a1f83d3e45da779f2e63c35d55_720w.jpg)

# 4 B树与B+树的区别
* B+树的层级更少：相较于B树B+每个非叶子节点存储的关键字数更多，树的层级更少所以查询数据更快；因为B+ 树非叶子节点上是不存储数据的，仅存储键值，而 B 树节点中不仅存储键值，也会存储数据。之所以这么做是因为在数据库中页的大小是固定的，InnoDB 中页的默认大小是 16KB。如果不存储数据，那么就会存储更多的键值，相应的树的阶数(节点的子节点树)就会更大，树就会更矮更胖，如此一来我们查找数据进行磁盘的 IO 次数又会再次减少，数据查询的效率也会更快。另外，B+ 树的阶数是等于键值的数量的，如果我们的 B+ 树一个节点可以存储 1000 个键值，那么 3 层 B+ 树可以存储 1000×1000×1000=10 亿个数据。

  一般根节点是常驻内存的，所以一般我们查找 10 亿数据，只需要 2 次磁盘 IO。

* B+树查询速度更稳定：B+所有关键字数据地址都存在叶子节点上，所以每次查找的次数都相同所以查询速度要比B树更稳定;

* B+树天然具备排序功能：B+树所有的叶子节点数据构成了一个有序链表，在查询大小区间的数据时候更方便，数据紧密性很高，缓存的命中率也会比B树高。

* B+树全节点遍历更快：B+树遍历整棵树只需要遍历所有的叶子节点即可，，而不需要像B树一样需要对每一层进行遍历，这有利于数据库做全表扫描。

* B树相对于B+树的优点是，如果经常访问的数据离根节点很近，而B树的非叶子节点本身存有关键字其数据的地址，所以这种数据检索的时候会要比B+树快。

* 参考：[平衡二叉树、B树、B+树、B*树 理解其中一种你就都明白了](https://zhuanlan.zhihu.com/p/27700617)，[[面试官问你B树和B+树，就把这篇文章丢给他]](https://segmentfault.com/a/1190000020416577)

